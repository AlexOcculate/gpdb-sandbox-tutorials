<!DOCTYPE html>
<html><head>

  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1"><title>Greenplum DB Tutorials by greenplum-db</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"></head><body>

      <header>
        </header><h1>Greenplum DB Tutorials</h1>
        <p>For use with the Greenplum DB Sandbox</p>
      

      <div style="margin-top: 20px; height: 51px;" id="banner">
        <span id="logo"></span>

        <a href="https://github.com/greenplum-db/gpdb-sandbox-tutorials" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/greenplum-db/gpdb-sandbox-tutorials/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/greenplum-db/gpdb-sandbox-tutorials/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        </nav><ul></ul>
      
      <section>
        </section><p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/GPDB.jpg" width="750"></p>

<h1 align="center">
<a id="an-introduction-and-greenplum-db-tutorial-using-the-gpdb-sandbox-vm" class="anchor" href="#an-introduction-and-greenplum-db-tutorial-using-the-gpdb-sandbox-vm" aria-hidden="true"><span class="octicon octicon-link"></span></a>An Introduction and Greenplum DB Tutorial using the GPDB Sandbox VM</h1>

<hr>

<p>These tutorials showcase how GPDB can address day-to-day tasks
performed in typical DW/BI environments. It is designed to be used with
the Greenplum Database Sandbox VM that is available for download.</p>

<p>The scripts/data for this tutorial are in the gpdb-sandbox virtual
machine at /home/gpadmin. The repository is pre-cloned, but will update
as the VM boots in order to provide the most recent version of these
instructions.</p>

<ul>
<li>Import the GPDB Sandbox Virtual Machine into VMware Fusion or Virutal Box</li>
<li>Start the GPDB Sandbox Virtual Machine.  Once the machine starts, you will see the following screen
<img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/Boot%20Image.jpg" alt="">
This screen provides you all the information you need to interact with the VM.

<ul>
<li>Username/Password combinations</li>
<li>Managment URLs</li>
<li>IP address for SSH Connection</li>
</ul>
</li>
</ul>

<p>Interacting with the Sandbox via a new terminal is preferable, as it makes many of the operations simpler.  </p>

<p><em>This tutorial is based on a freely-available datasets with statistics from the 2013 NFL Football Season.</em></p>

<h2>
<a id="tutorials" class="anchor" href="#tutorials" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="tutorials"></a>Tutorials</h2>

<ul>
<li><a href="#lesson0">Introduction to the Greenplum Database Architecture</a></li>
<li>
<a href="#lesson1">Lesson 1: Parallel Data Loading</a><br>
</li>
<li>
<a href="#lesson2">Lesson 2: Querying the Database</a><br>
</li>
<li>
<a href="#lesson3">Lesson 3: Creating Partitioned Tables</a> </li>
<li>
<a href="#lesson4">Lesson 4: Advanced Analytics with the Greenplum Database</a> </li>
<li>
<a href="#lesson5">Lesson 5: Backup and Recovery Operations</a> </li>
</ul>

<hr>

<h2>
<a id="introduction-to-the-greenplum-database--architecture" class="anchor" href="#introduction-to-the-greenplum-database--architecture" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="lesson0"></a>Introduction to the Greenplum Database  Architecture</h2>

<p><a href="http://greenplum.org">Pivotal Greenplum Database</a> is a
massively parallel processing (MPP) database server with an
architecture specially designed to manage large-scale analytic data
warehouses and business intelligence workloads.</p>

<p>MPP (also known as a shared nothing architecture) refers to systems
with two or more processors that cooperate to carry out an operation,
each processor with its own memory, operating system and disks.
Greenplum uses this high-performance system architecture to distribute
the load of multi-terabyte data warehouses, and can use all of a
system's resources in parallel to process a query.</p>

<p>Greenplum Database is based on PostgreSQL open-source technology. It
is essentially several PostgreSQL database instances acting together as
one cohesive database management system (DBMS). It is based on
PostgreSQL 8.2.15, and in most cases is very similar to PostgreSQL with
regard to SQL support, features, configuration options, and end-user
functionality. Database users interact with Greenplum Database as they
would a regular PostgreSQL DBMS.</p>

<p>The internals of PostgreSQL have been modified or supplemented to
support the parallel structure of Greenplum Database. For example, the
system catalog, optimizer, query executor, and transaction manager
components have been modified and enhanced to be able to execute
queries simultaneously across all of the parallel PostgreSQL database
instances. The Greenplum interconnect (the networking layer) enables
communication between the distinct PostgreSQL instances and allows the
system to behave as one logical database.</p>

<p>Greenplum Database also includes features designed to optimize
PostgreSQL for business intelligence (BI) workloads. For example,
Greenplum has added parallel data loading (external tables), resource
management, query optimizations, and storage enhancements, which are
not found in standard PostgreSQL. Many features and optimizations
developed by Greenplum make their way into the PostgreSQL community.
For example, table partitioning is a feature first developed by
Greenplum, and it is now in standard PostgreSQL.</p>

<p>Greenplum Database stores and processes large amounts of data by
distributing the data and processing workload across several servers or
hosts. Greenplum Database is an array of individual databases based
upon PostgreSQL 8.2 working together to present a single database
image. The master is the entry point to the Greenplum Database system.
It is the database instance to which clients connect and submit SQL
statements. The master coordinates its work with the other database
instances in the system, called segments, which store and process the
data.</p>

<p>Figure 1. High-Level Greenplum Database Architecture<br>
<img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/highlevel_arch.jpg" width="400">  </p>

<p>The following topics describe the components that make up a Greenplum Database system and how they work together. </p>

<p><strong>Greenplum Master</strong>
The Greenplum Database master is the entry to the Greenplum Database
system, accepting client connections and SQL queries, and distributing
work to the segment instances.</p>

<p>Greenplum Database end-users interact with Greenplum Database
(through the master) as they would with a typical PostgreSQL database.
They connect to the database using client programs such as psql or
application programming interfaces (APIs) such as JDBC or ODBC.</p>

<p>The master is where the global system catalog resides. The global
system catalog is the set of system tables that contain metadata about
the Greenplum Database system itself. The master does not contain any
user data; data resides only on the segments. The master authenticates
client connections, processes incoming SQL commands, distributes
workloads among segments, coordinates the results returned by each
segment, and presents the final results to the client program.</p>

<p><strong>Greenplum Segments</strong>
Greenplum Database segment instances are independent PostgreSQL
databases that each store a portion of the data and perform the
majority of query processing.</p>

<p>When a user connects to the database via the Greenplum master and
issues a query, processes are created in each segment database to
handle the work of that query. For more information about query
processes, see About Greenplum Query Processing.</p>

<p>User-defined tables and their indexes are distributed across the
available segments in a Greenplum Database system; each segment
contains a distinct portion of data. The database server processes that
serve segment data run under the corresponding segment instances. Users
interact with segments in a Greenplum Database system through the
master.</p>

<p>Segments run on a servers called segment hosts. A segment host
typically executes from two to eight Greenplum segments, depending on
the CPU cores, RAM, storage, network interfaces, and workloads. Segment
hosts are expected to be identically configured. The key to obtaining
the best performance from Greenplum Database is to distribute data and
workloads evenly across a large number of equally capable segments so
that all segments begin working on a task simultaneously and complete
their work at the same time.</p>

<p><strong>Greenplum Interconnect</strong>
The interconect is the networking layer of the Greenplum Database architecture.</p>

<p>The interconnect refers to the inter-process communication between
segments and the network infrastructure on which this communication
relies. The Greenplum interconnect uses a standard 10-Gigabit Ethernet
switching fabric.</p>

<p>By default, the interconnect uses User Datagram Protocol (UDP) to
send messages over the network. The Greenplum software performs packet
verification beyond what is provided by UDP. This means the reliability
is equivalent to Transmission Control Protocol (TCP), and the
performance and scalability exceeds TCP. If the interconnect used TCP,
Greenplum Database would have a scalability limit of 1000 segment
instances. With UDP as the current default protocol for the
interconnect, this limit is not applicable.</p>

<p><strong>Pivotal Query Optimizer</strong>
The Pivotal Query Optimizer brings a state of the art query
optimization framework to Greenplum Database that is distinguished from
other optimizers in several ways:</p>

<ul>
<li><p>Modularity. Pivotal Query Optimizer is not confined inside a
single RDBMS. It is currently leveraged in both Greenplum Database and
Pivotal HAWQ, but it can also be run as a standalone component to allow
greater flexibility in adopting new backend systems and using the
optimizer as a service. This also enables elaborate testing of the
optimizer without going through the other components of the database
stack.</p></li>
<li><p>Extensibility. The Pivotal Query Optimizer has been designed as
a collection of independent components that can be replaced,
configured, or extended separately. This significantly reduces the
development costs of adding new features, and also allows rapid
adoption of emerging technologies. Within the Query Optimizer, the
representation of the elements of a query has been separated from how
the query is optimized. This lets the optimizer treat all elements
equally and avoids the issues with the imposed order of optimizations
steps of multi-phase optimizers.</p></li>
<li><p>Performance. The Pivotal Query Optimizer leverages a multi-core
scheduler that can distribute individual optimization tasks across
multiple cores to speed up the optimization process. This allows the
Query Optimizer to apply all possible optimizations as the same time,
which results in many more plan alternatives and a wider range of
queries that can be optimized. For instance, when the Pivotal Query
Optimizer was used with TPC-H Query 21 it generated 1.2 Billion
possible plans in 250 ms. This is especially important in Big Data
Analytics where performance challenges are magnified by the volume of
data that needs to be processed. A suboptimal optimization choice could
very well lead to a query that just runs forever.</p></li>
</ul>

<p><a href="#tutorials">Return to Tutorial List</a>  </p>

<hr>

<h2>
<a id="lesson-1-parallel-data-loading" class="anchor" href="#lesson-1-parallel-data-loading" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="lesson1"></a>Lesson 1: Parallel Data Loading</h2>

<p>In a large scale, multi-terabyte data warehouse, large amounts of
data must be loaded within a relatively small maintenance window.
Greenplum supports fast, parallel data loading with its external tables
feature. Administrators can also load external tables in single row
error isolation mode to filter bad rows into a separate error table
while continuing to load properly formatted rows. Administrators can
specify an error threshold for a load operation to control how many
improperly formatted rows cause Greenplum to abort the load operation.</p>

<p>By using external tables in conjunction with Greenplum Database's
parallel file server (gpfdist), administrators can achieve maximum
parallelism and load bandwidth from their Greenplum Database system.</p>

<p>Figure 1. External Tables Using Greenplum Parallel File Server (gpfdist) </p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/ext_tables.jpg" width="500"></p>

<p>Another Greenplum utility, gpload, runs a load task that you specify
in a YAML-formatted control file. You describe the source data
locations, format, transformations required, participating hosts,
database destinations, and other particulars in the control file and
gpload executes the load. This allows you to describe a complex task
and execute it in a controlled, repeatable fashion.</p>

<p><strong>Exercises</strong><br>
This tutorial will demonstrate how to load an external csv delimited file into the Greenplum Database using the <strong>gpfdist</strong> parallel data load utility.</p>

<ol>
<li>
<p>From a terminal, ssh to the Sandbox VM as gpadmin using the IP Address found in the boot-up screen (as seen below)  </p>

<blockquote>
<p><code>ssh gpadmin@X.X.X.X</code>  In the example shown, this would be ssh gpadmin@192.168.9.132 </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/Boot_Image_HLjpg.jpg" width="800"></p>
</li>
<li>
<p>If you haven't already started the Greenplum Database.  </p>

<blockquote>
<p><code>./start_all.sh</code>  </p>
</blockquote>
</li>
<li>
<p>Change to the tutorials directory.</p>

<blockquote>
<p><code>cd gpdb-sandbox-tutorials</code>  </p>
</blockquote>
</li>
<li>
<p>The first step is to create the database and the associated tables
for these demos. To make the process easier, a script has been provided
that contains all the needed ddl statements. Here is a look inside the
file:<br>
 <img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/create.jpg" width="500"><br>
 Execute the DDL file and create the tables.  </p>

<blockquote>
<p><code>psql -f create_tables.sql</code> -</p>
</blockquote>
</li>
<li>
<p>Now, we need to setup <strong>gpfdist</strong> to serve the external data file.</p>

<p>First, start the <strong>gpfdist</strong> utility.  </p>

<blockquote>
<p><code>gpfdist -d /home/gpadmin/gpdb-sandbox-tutorials/data -p 8081 -l /home/gpadmin/gpdb-sandbox-tutorials/gpfdist.log &amp;</code></p>
</blockquote>

<p>This will start the gpfdist server with the data directory as its
source, so that any external tables built will be able to poin to any
files there firectly or via a wildcard. In this example, we will point
to the file directly.</p>

<p>Now, we can create an Greenplum External Table to point directly to
the data file. There is a pre-created shell-script to do this. The
script removes the tables if it already exists and the creates an
external table in the image of the playbyplay table create in an
earlier step. </p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/exttable.jpg" width="800">
Execute the DDL script to create the external table.</p>

<blockquote>
<p><code>psql -f ext_table.sql</code>   </p>
</blockquote>
</li>
<li>
<p>We can now load a native Greenplum table (playbyplay) by querying
the external table directly and inserting the data. But first we will
run a couple of quick tests to show a before and after look at the
tables.<br>
Start psql:</p>

<blockquote>
<p><code>psql</code> </p>
</blockquote>

<p>Now, let's generate a count of the rows in the playbyplay table that was created earlier.<br>
At the psql prompt type:  </p>

<blockquote>
<p><code>select count(*) from playbyplay;</code>  </p>
</blockquote>

<p>This should return a count of 0 rows. If we run the same command
against the external table we will get a count of the rows in our data
file. From the psql prompt type:</p>

<blockquote>
<p><code>select count(*) from ext_playbyplay;</code>  </p>
</blockquote>

<p>This returns 47990 rows.  </p>
</li>
<li>
<p>Now the data can be loaded into Greenplum using a psql command.  </p>

<blockquote>
<p><code>insert into playbyplay (select * from ext_playbyplay);</code>   </p>
</blockquote>

<p>Since we are querying a file that is being accessed via gpfdist, the
load happens in parallel across all segments of the Greenplum Database.
Further scalability can be achieved by running multiple gpfdist
instances and having multiple datafile. Once, the load is complete, we
can check the count of rows in the playbyplay table again. From the
psql prompt type: </p>

<blockquote>
<p><code>select count(*) from playbyplay;</code>    </p>
</blockquote>

<p>Now, it should report 47990 rows, or the same number from our data file.<br>
Log out of psql by typing: <code>\q</code> then press enter.</p>
</li>
<li>
<p>External Tables can also point at sources other than local files.
Web External tables allow Greenplum Database to treat dynamic data
sources like regular database tables. The sources can be either a linux
command or a URL. In this example, we will read the weather information
for 2013 directly from the GitHub site that this tutorial is stored.
Look inside the provided DDL script to see how the web external table
is created.</p>

<blockquote>
<p><code>more ext_web_tables.sql</code></p>
</blockquote>

<p>To create the web external table, execute the following DDL script.</p>

<blockquote>
<p><code>psql -f ext_web_tables.sql</code></p>
</blockquote>
</li>
<li>
<p>Start the psql client, type: <code>psql</code></p>

<p>You can test the Web External Table by just querying some rows. Run the following query to test.  </p>

<blockquote>
<p><code>select * from ext_weather limit 10;</code></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/webtest.jpg" width="800">  </p>
</li>
<li>
<p>Now, we can load the data from the External Web Table into the Greenplum Database.  From the psql prompt type:</p>

<blockquote>
<p><code>insert into weather (select * from ext_weather);</code>  </p>
</blockquote>

<p>This should report that 22384 rows were inserted.
You can also query the newly loaded table to verify the table load.  </p>

<blockquote>
<p><code>select * from weather limit 10;</code></p>
</blockquote>

<p>This should return a data set that resembles the one shown above for ext_weather.</p>
</li>
</ol>

<p>This concludes the lesson on Loading Data into the Greenplum Database.  The next lesson will cover querying the database.   </p>

<p><a href="#tutorials">Return to Tutorial List</a>  </p>

<hr>

<h2>
<a id="lesson-2-querying-the-database" class="anchor" href="#lesson-2-querying-the-database" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="lesson2"></a>Lesson 2: Querying the Database</h2>

<p>This lesson provides an overview of how Greenplum Database processes
queries. Understanding this process can be useful when writing and
tuning queries.</p>

<p>Users issue queries to Greenplum Database as they would to any
database management system. They connect to the database instance on
the Greenplum master host using a client application such as psql and
submit SQL statements. In this lesson, you will use <a href="https://zeppelin.incubator.apache.org/">Apache Zeppelin (incubating)</a>
to submit SQL statements to the Greenplum Database. Apache Zeppelin is
a web-based notebook that enables interactive data analytics. A <a href="https://issues.apache.org/jira/browse/ZEPPELIN-250">PostgeSQL interpreter</a> has been added to Zeppelin, so that it can now work directly with products such as Pivotal Greenplum Database and Pivotal HDB. </p>

<p><strong>Understanding Query Planning and Dispatch</strong><br>
The master receives, parses, and optimizes the query. The resulting
query plan is either parallel or targeted. The master dispatches
parallel query plans to all segments, as shown in Figure 1. Each
segment is responsible for executing local database operations on its
own set of data.query plans.</p>

<p>Most database operations—such as table scans, joins, aggregations,
and sorts—execute across all segments in parallel. Each operation is
performed on a segment database independent of the data stored in the
other segment databases.</p>

<p>Figure 1. Dispatching the Parallel Query Plan<br>
<img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/dispatch.jpg" width="400"></p>

<p><strong>Understanding Greenplum Query Plans</strong><br>
A query plan is the set of operations Greenplum Database will perform
to produce the answer to a query. Each node or step in the plan
represents a database operation such as a table scan, join,
aggregation, or sort. Plans are read and executed from bottom to top.</p>

<p>In addition to common database operations such as tables scans,
joins, and so on, Greenplum Database has an additional operation type
called motion. A motion operation involves moving tuples between the
segments during query processing.</p>

<p>To achieve maximum parallelism during query execution, Greenplum
divides the work of the query plan into slices. A slice is a portion of
the plan that segments can work on independently. A query plan is
sliced wherever a motion operation occurs in the plan, with one slice
on each side of the motion.</p>

<p><strong>Understanding Parallel Query Execution</strong> Greenplum
creates a number of database processes to handle the work of a query.
On the master, the query worker process is called the query dispatcher
(QD). The QD is responsible for creating and dispatching the query
plan. It also accumulates and presents the final results. On the
segments, a query worker process is called a query executor (QE). A QE
is responsible for completing its portion of work and communicating its
intermediate results to the other worker processes.</p>

<p>There is at least one worker process assigned to each slice of the
query plan. A worker process works on its assigned portion of the query
plan independently. During query execution, each segment will have a
number of processes working on the query in parallel.</p>

<p>Related processes that are working on the same slice of the query
plan but on different segments are called gangs. As a portion of work
is completed, tuples flow up the query plan from one gang of processes
to the next. This inter-process communication between the segments is
referred to as the interconnect component of Greenplum Database. </p>

<p><strong>Exercises</strong><br>
Now, that query execution has been explained, let's run some queries.</p>

<ol>
<li>
<p>From a terminal, ssh to the Sandbox VM as gpadmin using the IP Address found in the boot-up screen (as seen below)  </p>

<blockquote>
<p><code>ssh gpadmin@X.X.X.X</code>  </p>
</blockquote>

<p>In the example shown, this would be ssh gpadmin@192.168.9.132</p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/Boot_Image_HLjpg.jpg" width="800">  </p>
</li>
<li>
<p>Start the Greenplum Database if you haven't already started it.</p>

<blockquote>
<p><code>./start_all.sh</code>  </p>
</blockquote>
</li>
<li><p>Open a browser on your desktop and browse to <code>http://X.X.X.X:8080</code> using the same IP address that you used for the ssh step. You will see the Apache Zepplin Welcome page.
<img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/zepp.jpg" width="500">  </p></li>
<li><p>Click on Create new note underneath the Notebook heading and type: <code>tutorial</code>
<img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/zep-create.jpg" width="500">  </p></li>
<li><p>Click "tutorial" to open the newly created notebook. Or, if you
prefer, there is already a notebook created called football that has
the queries and paragraphs pre-created. If you choose this option, the
Interpretor Binding options will display at the top, scroll down and
hit save to close this portion of the screen.</p></li>
<li>
<p>You should now see the the open notebook with a "paragraph" ready
for input. Click in the the empty white rectangle (called paragraph)
and type: </p>

<blockquote>
<p><code>%psql.sql select count(*) from playbyplay;</code>  </p>
</blockquote>

<p>The result should look like the graphic below.</p>
</li>
<li>
<p>Next, let's try a more compex query and try out some of the visualization features of Zepplin. In a new paragraph type:</p>

<blockquote>
<pre><code>%psql.sql  SELECT p.offense,w.temperature,count(*) FROM weather w,<br>playbyplay p WHERE w.date=p.gamedate AND (upper(w.hometeam) = p.offense<br>OR upper(w.hometeam) = p.defense) AND p.isinterception = true<br>AND p.offense SIMILAR TO '[ABCD]%' GROUP BY p.offense,w.temperature  <br>ORDER BY p.offense;<br></code></pre>
</blockquote>

<p>This should return a data set showing team abbreviation, game
temperature, and number of interceptions. This query scans all the
offensive plays in 2013 and returns any that were interceptions and the
temperature of that game for teams that begin with A,B,C, or D. </p>
</li>
</ol>

<ol>
<li>There is a row of icons underneath the query. The one on the far
right is a scatter-plot, click that. You will then be able to drag the
fields of the query into the axis of the plot. Drag offense to the
xAxis, temperature to the yAxis, and count to size. You should now see
a scatter plot with the vertical axis showing the number of
interceptions per team at a given temperature. The size of the "dot"
represents the relative number of interceptions.<br>
<img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/scatter.jpg" width="800"><br>
</li>
<li>The final query leverages subquerys to determine how many
interceptions each team threw at home versus on the road for the
season. Once again, for display purposes, the teams have been limited
to those beginning with A-D.</li>
</ol>

<blockquote>
<pre><code>%psql.sql select home.team,home.homeint,road.roadint from (select p.offense<br>as team,count(*) as roadint from weather w,playbyplay p <br>where w.date=p.gamedate and (upper(w.hometeam) =  p.defense) and <br>p.isinterception = true group by p.offense) road,<br>(select p.offense as team ,count(*) as homeint from weather w,<br>playbyplay p where w.date=p.gamedate and (upper(w.hometeam) =  p.offense)<br>and p.isinterception = true group by p.offense) home <br>where home.team = road.team and home.team similar to '[ABCD]%'  <br>order by homeint;  <br></code></pre>
</blockquote>

<p><a href="#tutorials">Return to Tutorial List</a>  </p>

<hr>

<h2>
<a id="lesson-3-creating-partitioned-tables" class="anchor" href="#lesson-3-creating-partitioned-tables" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="lesson3"></a>Lesson 3: Creating Partitioned Tables</h2>

<p>Table partitioning enables supporting very large tables, such as
fact tables, by logically dividing them into smaller, more manageable
pieces. Partitioned tables can improve query performance by allowing
the Greenplum Database query optimizer to scan only the data needed to
satisfy a given query instead of scanning all the contents of a large
table.</p>

<p>Partitioning does not change the physical distribution of table data
across the segments. Table distribution is physical: Greenplum Database
physically divides partitioned tables and non-partitioned tables across
segments to enable parallel query processing. Table partitioning is
logical: Greenplum Database logically divides big tables to improve
query performance and facilitate data warehouse maintenance tasks, such
as rolling old data out of the data warehouse.</p>

<p>Greenplum Database supports:</p>

<ul>
<li>Range partitioning: division of data based on a numerical range, such as date or price.<br>
</li>
<li>List partitioning: division of data based on a list of values, such as sales territory or product line.<br>
</li>
<li>A combination of both types.<br>
</li>
</ul>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/part.jpg" width="400">  </p>

<p><strong>Exercises</strong>  </p>

<p>This exercise will demonstrate how to create a range partitioned table and loading it via external table.</p>

<p>The DDL to create the partitioned table is in the file create_part.sql. This snapshot shows the relevant portion of the file.  </p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/createpart.jpg" width="600">  </p>

<p>This statement defines a RANGE partition using the date the player
was drafted as the partition key. The START/END represent the high and
low of the values in that column. EVERY defines the partition
granularity or how many of the values from the range will be within a
single partition. The DEFAULT PARTITION is the partition that values
that don't match any of the defined partitions are inserted into. </p>

<p>First, create the partitioned table and the External Table use to query the data file:</p>

<blockquote>
<p><code>psql -f create_part.sql</code>  </p>
</blockquote>

<p>This is the output from that ddl.  You can see the partitions were created.  </p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/part-output.jpg" width="600">  </p>

<p>Now, query the external data and insert data into the partitioned table.<br>
Launch psql:  </p>

<blockquote>
<p><code>psql</code>  </p>
</blockquote>

<p>Then, type:  </p>

<blockquote>
<p><code>insert into players (select * from ext_players);</code></p>
</blockquote>

<p><a href="#tutorials">Return to Tutorial List</a>  </p>

<hr>

<h2>
<a id="lesson-4-advanced-analytics-with-the-greenplum-database" class="anchor" href="#lesson-4-advanced-analytics-with-the-greenplum-database" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="lesson4"></a>Lesson 4: Advanced Analytics with the Greenplum Database</h2>

<p><strong><em>COMING SOON!</em></strong></p>

<hr>

<h2>
<a id="lesson-5-backup-and-recovery-operations" class="anchor" href="#lesson-5-backup-and-recovery-operations" aria-hidden="true"><span class="octicon octicon-link"></span></a><a name="lesson5"></a>Lesson 5: Backup and Recovery Operations</h2>

<p>The Greenplum Database parallel dump utility gpcrondump backs up the
Greenplum master instance and each active segment instance at the same
time.</p>

<p>By default, gpcrondump creates dump files in the gp_dump subdirectory.</p>

<p>Several dump files are created for the master, containing database
information such as DDL statements, the Greenplum system catalog
tables, and metadata files. gpcrondump creates one dump file for each
segment, which contains commands to recreate the data on that segment.</p>

<p>You can perform full or incremental backups. To restore a database
to its state when an incremental backup was made, you will need to
restore the previous full backup and all subsequent incremental backups.</p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/backup.jpg" width="400"> </p>

<p>Each file created for a backup begins with a 14-digit timestamp key that identifies the backup set the file belongs to.</p>

<p>gpchrondump can be run directly in a terminal on the master host, or
you can add it to crontab on the master host to schedule regular
backups.</p>

<p><strong>Exercises</strong></p>

<p>These exercises will walk through how to create a full backup of your database and then restore a table.</p>

<p>1) To run a full backup, use "gpcrondump -x database -u
/path/for/backup -a". This will backup the entire database to the
directory given without prompting the user.</p>

<blockquote>
<p><code>gpcrondump -x gpadmin -u /tmp -a</code></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/gpcrondump.jpg" width="600"> </p>

<p>This runs a full backup of the database created during the previous exercises.  To view the backups:</p>

<blockquote>
<p><code>ls -al /tmp/db_dumps</code>  </p>
</blockquote>

<p>The Greenplum Database parallel restore utility gpdbrestore takes
the timestamp key generated by gpcrondump, validates the backup set,
and restores the database objects and data into a distributed database
in parallel. Parallel restore operations require a complete backup set
created by gpcrondump, a full backup and any required incremental
backups. </p>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/restore.jpg" width="400"> </p>

<p>The Greenplum Database gpdbrestore utility provides flexibility and
verification options for use with the automated backup files produced
by gpcrondump or with backup files moved from the Greenplum array to an
alternate location. </p>

<p>Now, that we have a full backup let's remove data from a table to simulate a failure.  Type <code>psql</code> to bring up a psql prompt:</p>

<blockquote>
<p><code>select count(*) from weather;</code></p>
</blockquote>

<p>This should return 22384 rows in the table.  Let's truncate the table and then check the row count:</p>

<blockquote>
<pre><code>truncate table weather;<br>select count(*) from weather;<br></code></pre>
</blockquote>

<p>The report should now show 0 rows in the table. So, let's restore the data. First, exit from the psql shell by typing <code>\q</code> then issue the gpdbrestore command:</p>

<blockquote>
<p><code>gpdbrestore -T public.weather -s gpadmin -u /tmp -a</code></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/greenplum-db/gpdb-sandbox-tutorials/gh-pages/images/gpdbrestore.jpg" width="600"> </p>

<p>Once this is complete, launch the psql shell again: <code>psql</code> and then check the status of the weather table:</p>

<blockquote>
<p><code>select count(*) from weather;</code></p>
</blockquote>

<p>The table should show 22384 rows again as it was prior to the truncate call.</p>
      
      <footer>
        </footer><p>Project maintained by <a href="https://github.com/greenplum-db">greenplum-db</a></p>
        <p><small>Hosted on GitHub Pages — Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body></html>
